

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=dark>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="leeseven-li">
  <meta name="keywords" content="">
  
    <meta name="description" content="spak QAspark为什么比mapreduce快 内存：高效的内存管理和缓存机制比，堆内堆外内存，序列化以及缓存机制，实现数据的内存计算。   shuffle：spark的shuffle种类比较多有hash shuffle、sort shuffle。mapreduce的shuffle需要排序，也没与什么可选的其他方案   DAG：通过有向无环图，可以有效的减少shuffle次数。清楚的知道每个">
<meta property="og:type" content="article">
<meta property="og:title" content="spark-QA">
<meta property="og:url" content="https://blog.leeseven.online/2024/01/12/spark-QA/index.html">
<meta property="og:site_name" content="大数据&#x2F;开源&#x2F;分享">
<meta property="og:description" content="spak QAspark为什么比mapreduce快 内存：高效的内存管理和缓存机制比，堆内堆外内存，序列化以及缓存机制，实现数据的内存计算。   shuffle：spark的shuffle种类比较多有hash shuffle、sort shuffle。mapreduce的shuffle需要排序，也没与什么可选的其他方案   DAG：通过有向无环图，可以有效的减少shuffle次数。清楚的知道每个">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/leeseven1211/PictureBed/main/img/spark-netty-rpc-env.png">
<meta property="article:published_time" content="2024-01-12T03:28:52.000Z">
<meta property="article:modified_time" content="2024-01-12T03:31:42.019Z">
<meta property="article:author" content="leeseven-li">
<meta property="article:tag" content="spark">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://raw.githubusercontent.com/leeseven1211/PictureBed/main/img/spark-netty-rpc-env.png">
  
  
  <title>spark-QA - 大数据/开源/分享</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hint.css@2/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"blog.leeseven.online","root":"/","version":"1.8.14","typing":{"enable":true,"typeSpeed":30,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 6.0.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Leeseven&#39;s 博客</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/hy.jpeg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="spark-QA">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2024-01-12 11:28" pubdate>
        2024年1月12日 上午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      6k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      51 分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">spark-QA</h1>
            
            <div class="markdown-body">
              <h1 id="spak-QA"><a href="#spak-QA" class="headerlink" title="spak QA"></a>spak QA</h1><h2 id="spark为什么比mapreduce快"><a href="#spark为什么比mapreduce快" class="headerlink" title="spark为什么比mapreduce快"></a>spark为什么比mapreduce快</h2><ul>
<li>内存：高效的内存管理和缓存机制比，堆内堆外内存，序列化以及缓存机制，实现数据的内存计算。  </li>
<li>shuffle：spark的shuffle种类比较多有hash shuffle、sort shuffle。mapreduce的shuffle需要排序，也没与什么可选的其他方案  </li>
<li>DAG：通过有向无环图，可以有效的减少shuffle次数。清楚的知道每个数据的血缘关系，如果出错不用重新计算，可以只计算失败的部分。  </li>
<li>资源调度：粗粒度资源调度可在运行的时候申请好需要的资源然后每个executor里面可以多线程并行执行。</li>
</ul>
<h2 id="spark内存管理"><a href="#spark内存管理" class="headerlink" title="spark内存管理"></a>spark内存管理</h2><ul>
<li>spark1.6之前是静态内存管理分为：storage&#x3D;0.6、execution&#x3D;0.2、other&#x3D;0.2，每个地方内存是固定的  </li>
<li>spark1.6之后是统一内存管理：storage和exection统一归为一块内存，可以相互占用。整体预留300M，剩下的other内存，用来存放spark元数据和用户自定义的数据结构。  </li>
<li>动态占用机制：存储内存不够的时候可以占用执行内存的内存，如果执行内存需要的时候会把存储内存要回来，而执行内存占用存储内存只能等执行内存释放之后存储内存才可以使用  </li>
<li>storage memory：主要是用来缓存rdd使用  </li>
<li>execution memory：主要用来spark shuffle中间数据的保存，像map输出到内存以及相关的排序过程。  </li>
<li>堆外内存：不管是静态内存还是统一内存都是有堆外内存的，默认是384M。其中执行和存储各占50%。堆外内存基于字节存储，节约内存，可以脱离jvm的限制，减少了gc的干扰。对于大数组存储和内存的重复只用效率很高。  </li>
<li>memoryManager：对于内存的管理不管是对内对外还是静态动态内存管理，统一抽象为了MemoryManager，内存对应着storage memory和execution memory包含了俩个内存池，StorageMemoryPool和StorageMemoryPool对于内存的申请和释放，还有内存的借用。</li>
</ul>
<h2 id="spark通信框架"><a href="#spark通信框架" class="headerlink" title="spark通信框架"></a>spark通信框架</h2><p><img src="https://raw.githubusercontent.com/leeseven1211/PictureBed/main/img/spark-netty-rpc-env.png" srcset="/img/loading.gif" lazyload alt="spark通信">  </p>
<ol>
<li>RpcEndpoint：RPC端点，Spark针对每个节点（master worker client）都称之为一个RPC端点，都实现了RPCEndpoint接口，内部根据不同端点的需求，设计bu不同的消息和不同的业务处理，如需发送&#x2F;询问调用Dispacther  </li>
<li>RpcEnv：RPC的上下文环境，每个Rpc端点运行时依赖的上下文环境称之为RpcEnv。  </li>
<li>Disppatcher：消息分发器，针对于RPC端点需要发送消息&#x2F;接收消息，分别发送到对应的发件箱&#x2F;收件箱。  </li>
<li>Inbox：指令收件箱，一个端点对应一个收件箱，Dispatcher每次往收件箱放入消息，就会把消息放到了一个receive queue里面，在启动Dispatcher的时候会启动一个线程轮询去扫描queue里面的消息，并发送到RpcEnpoint里面去处理。  </li>
<li>Outbox：指令发件箱：一个远程端点对应一个发件箱，消息放到Outbox里面就会通过TransportClient发送到远端的端点上。发送消息分为俩种：RpcOutboxMessage和OneWayOutboxMessage。针对需要应答的消息直接发送而且需要等待回复结果之后进行处理。  </li>
<li>TransportClient：netty通信客户端，根据outBox消息的receiver信息，请求远程TransportServer  </li>
<li>TransportServer：netty通信服务端，一个RPCd端点对应一个TransportServer，接受远端的消息后调用Dispatcher进行消息的分发。</li>
</ol>
<h2 id="spark-shuffle"><a href="#spark-shuffle" class="headerlink" title="spark shuffle"></a>spark shuffle</h2><p>        spark整体流程，在触发job的时候，首先是由DAGScheduler来根据宽窄依赖从finalStage往前划分stage，然后划分好的stage交给TaskScheduler来调度。如果存在宽依赖，就存在shuffle，shuffle上面总体分为shufllemapTask和ResultTask，shuffleMapTaks主要是map的根据reduce来进行数据的划分，最后把mapoutput放到MapOutputTracker里面，resultTask从driver端的outputTracker里面获取map输出的结果信息，然后拉取自己的信息部分，然后进行合并。  </p>
<p>        spark shuffle演变过程是从刚开始的hash shuffle 到 sort base shuffle 到 Tunsten-sort base shuffle 演变过程。中间还有一些优化，像hashshuffle 针对于数据量相对来说比较小的效率比较高，但是生成的小的文件个数比较多，consoladation hash shuffle是对hashmap的优化，针对于同一个executor的task输出的文件使用同一个ShuffleFileGroup，不会每执行一个task就生成reduce个数的小文件，同时有了sort shuffle之后，其实还是可以使用hash shuffle的，这个是sort shuffle的bypass机制，因为在数据量比较小的时候hash shuffle的效率会更高写，而sort shuffle跟mapreduce类似中间可能需要对数据进行排序溢写等操作，最后tunsten shuffle这个databricksg公司提出对spark内存和cpu进行优化的一种sshuffle，限制条件是比较多。tunsten-sort是对序列化的二进制数据进行排序的，减少了内存的使用和gc带来的性能开销，对于二进制引入了指针的操作。  </p>
<h2 id="spark-dataframe-和-dataset区别"><a href="#spark-dataframe-和-dataset区别" class="headerlink" title="spark dataframe 和 dataset区别"></a>spark dataframe 和 dataset区别</h2><ul>
<li>dataset是强类型的支持编译期检查 dataframe是弱类型运行时候才能发现类型，dataset<row> &#x3D; dataframe  </li>
<li>dataframe更像是一个二维表。存储的结构化数据。dataset整合了rdd和dataframe的优点  </li>
<li>dataset 底层是字节存储（使用encoder对数据进行编码），给catalyst提供了更大的优化空间，同时合理使用了对外内存还有spark的序列化机制提高整体运行效率</li>
</ul>
<h2 id="sparksql几种join的实现"><a href="#sparksql几种join的实现" class="headerlink" title="sparksql几种join的实现"></a>sparksql几种join的实现</h2><ol>
<li>broadcast hash join  </li>
<li>sort merge join  </li>
<li>hash join  </li>
<li>broascast nested loop join  </li>
<li>cartesian product jin</li>
</ol>
<p>如何选择join策略？</p>
<h3 id="broadcast-hash-join"><a href="#broadcast-hash-join" class="headerlink" title="broadcast hash join"></a>broadcast hash join</h3><p>        其中主要就是俩个阈值，一个就是spark.sql.autoBroadcastJoinThreshold，这个参数控制着较小表的大小不能超过这个值，如果超过这个值不会执行bhj策略。其实还有一个行数限制，如果行数小于MAX_BROADCAST_TABLE_ROWS才会被广播。</p>
<h3 id="sort-merge-join"><a href="#sort-merge-join" class="headerlink" title="sort merge join"></a>sort merge join</h3><p>        其实hash join在特定条件下是比smj的效率高的，为什么把smj放在join，因为smj比hj稳定而且所有等值连接都可以使用的join策略，也是默认选择的join策略，适应场景也是最多的。</p>
<h3 id="hash-join"><a href="#hash-join" class="headerlink" title="hash join"></a>hash join</h3><p>        hash join的话，因为需要把小表分发之后再reduce内部建立hash表，这个hash表是需要内存的，所以就会对数据有要求，但是我们知道分发之后的数据可能会出现倾斜情况，所以不是即使小表不是很大，分发到reduce之后数据平均更小，但是有可能也会面临着oom的风险，而且带来的收益也不可控。想要使用这个join策略，小表的大小必须小于 shuffle分区数*spark.sql.autoBroadcastJoinThreshold ，还有就是大表必须是小表的三倍以上，不然带来的收益可能还没用smj带来的收益大。</p>
<p>        当然，如果数据均匀，满足条件的话，hj 肯定是比 smj 收益大的。</p>
<h3 id="broascast-nested-loop-join"><a href="#broascast-nested-loop-join" class="headerlink" title="broascast nested loop join"></a>broascast nested loop join</h3><p>        bnlj的话，肯定是不等值连接的首选，相当于笛卡尔积，但是小表一侧可以满足广播。</p>
<h3 id="cartesian-product-join"><a href="#cartesian-product-join" class="headerlink" title="cartesian product join"></a>cartesian product join</h3><p>        以上都不能满足的话使用这种，其实就是俩曾for循环，对所有数据进行遍历连接。</p>
<h2 id="spark3-AQE"><a href="#spark3-AQE" class="headerlink" title="spark3 AQE"></a>spark3 AQE</h2><p>自动分区合并、数据倾斜、join策略调整</p>
<h3 id="自动分区合并"><a href="#自动分区合并" class="headerlink" title="自动分区合并"></a>自动分区合并</h3><p>        map阶段，我们执行完一些算子之后，可能某些partition已经所剩无几了，这时候可能对多个partition进行合并，充分利用计算资源，避免过多的调度开销。（我们可能会使用repartition或者coalesce进行分区合并），有了aqe我们完全可以不用管。</p>
<p>        reduce阶段，每个reduce在拉取属于自己的分区数据的时候，可能有一些task下面的数据会比较少，这时候aqe起作用就会把这些分区数据较少的分区进行合并，我们原来可能设置reduce数量都不能解决的问题，遇到这种情况就可以解决了。</p>
<h4 id="数据倾斜"><a href="#数据倾斜" class="headerlink" title="数据倾斜"></a>数据倾斜</h4><p>           数据倾斜的话我们可能现在各种方法可以解决，基本上加盐都可以解决。有了aqe的话，识别到某个分区比较大的时候，aqe会自动把大分区拆分，使用不同的task去处理。但是极端情况下，倾斜特别严重的情况aqe是无法处理的，因为aqe的数据倾斜处理本质上还是在一个executor下面进行拆分taks去执行的，如果所有倾斜数据都在一个executor下面，拆分了跟没拆基本上一致的，所以这个机制只能解决一些倾斜不太严重的情况。</p>
<h4 id="自动join策略选择"><a href="#自动join策略选择" class="headerlink" title="自动join策略选择"></a>自动join策略选择</h4><p>        这个就更实用了，之前我们可能总会有一些这样的问题，俩个表join，因为不能够满足broadcast join的阈值，这样最红都会选择sort merge join，但是可能存在一张表经过一系列的清洗，在shuffle之前这个数据预警可以满足broadcast hash join的阈值了，但是因物理执行计划已经固定不能变了， 只能通过shuffle来解决，这种时候aqe就可以动态判断数据满足不满足broadcast的阈值了，有效避免了shuffle操作（当然，有人会说，map阶段都完成了输出到了不同的map file里面了，这种在执行broadcast也提升不了剩性能，其实这种后map数据就不在分发了，而是直接通过本地的数据进行join，这样减少了大表的分发，还是可以提升不少性能的）。</p>
<h2 id="Spark-DPP"><a href="#Spark-DPP" class="headerlink" title="Spark DPP"></a>Spark DPP</h2><p>        动态分区裁剪：分区裁剪可以说是大数据执行引擎里面对效率提升最高梯队，因为可以大大减少数据的输入量。DPP 增加了个动态，就是在执行过程中对分区进行裁剪，本质上就是一个表根据另外一个表的join key 关联到自己的分区字段，然后减少分区的使用量。这样的话另外一个表需要满足广播的阈值才能进行广播。</p>
<h2 id="大表join大表"><a href="#大表join大表" class="headerlink" title="大表join大表"></a>大表join大表</h2><p>        分而治之，把大表拆分成小表，然后通过bhj来进行join。特定情况下，把俩个表都进行拆分，然后一个表足够小可以放到内存里面，然后把不同的数据集union到一起，注意下union到一起，必须把数据拆分完全拆开，其实跟分桶的类似，关联到一起的不会出现在其他join sql里面， 这样才能把结果union到一起。还可以结合DPP机制来实现，这种场景实施起来比较少。</p>
<p>        如果大表关联大表还有倾斜的key，总体上可以把表拆分开，一个部分是分布均匀的key进行关联，另外一部分是分布不均匀的key进行关联，按照joinkey进行拆分，最终结果也可以通过union到一起。倾斜的key可以通过常规数据倾斜处理操作进行处理（俩阶段shuffle）。</p>
<h2 id="broadcast不能容纳小表"><a href="#broadcast不能容纳小表" class="headerlink" title="broadcast不能容纳小表"></a>broadcast不能容纳小表</h2><p>        如果遇到小表太大不足以放到内存的情况下，我们应该想法把这个表放到内存。总结几种情况。</p>
<ol>
<li>针对join表进行列裁剪，裁剪到可以容纳到内存，如果小表使用的列比较多而且都是join字段的话，可以使用hash的方法，把join的字段连和到一起进行hash，这样join字段就需要的很少，hash值跟之前多个字段相比，肯定能大大减少表大小，hash的话最好使用二次hash或者三次hash避免hash冲突。</li>
<li>使用aqe动态调整join策略，因为原始数据确实已经超过了广播的阈值，而且很大，但是如果维表进行过滤的话，根据业务条件可以知道过滤之后的数据剩下的不过了，但是维表也没有进行分区之类，这时候最好开启aqe然后根据map输出的文件大小动态调整大小，如果过滤之后的表满足了broadcast hash join，那么也会动态调整</li>
<li>如果我们小表相对来说都比较均匀，这时候我们可以强制使用hash join，因为每个reduce下面的小表数据都是均匀的，这时候不会发生oom的情况，这时候直接强制join hints 来使用hash join，性能肯定能提升不少。</li>
</ol>
<h2 id="catalyst-优化器"><a href="#catalyst-优化器" class="headerlink" title="catalyst 优化器"></a>catalyst 优化器</h2><p>        spark sql执行计划大概是：sql语句–&gt;ast语法树–&gt;unresolved logical plan–&gt;analysize logical plan –&gt; physical plan –&gt; optimize physical plan。</p>
<p>        其中catalyst主要作用在逻辑执行计划和物理执行计划，对应的是RBO和CBO。RBO就是基于规则的逻辑执行优化，根据我们的经验可以对执行计划有哪些优化，这些优化形成了各种各样的规则，把这些规则套用在我们的执行计划上面最终输出一个优化过的逻辑执行计划。CBO主要是基于一些统计信息对我们的生成物理执行执行计划优化，比如一个大表一个小表，我们根据规则根本不知道这些表的实际情况，但是我们有了这些表的实际统计信息就可以借助这些信息来进一步对我们的物理执行计划优化，小表是不是可以放到内存等。</p>
<p>        逻辑执行计划主要分为俩部分，一部分是对未解析的逻辑执行计划进行解析，另外一部分就是基于已经定好的规则对我们的逻辑执行计划进行转换。逻辑计划解析其实就是基于catalog去查询我们sql语句中对应实际的元数据，把我们所需要的数据信息都拿到跟我们解析的语法树中的节点对应关联起来。另外就是逻辑计划优化，我们对逻辑计划进行解析了，我们知道了这个表实际有多少字段，我们需要多少字段，数据字段是什么类型以及数据文件是基于什么存储的，这时候我们对计划进行优化，通过我们积累的这些优化规则，比如谓词下推，列裁剪，还有常量替换等，整理出来了好多组的优化规则套用在我们的逻辑执行计划上面进行优化。</p>
<p>        有了优化过的逻辑执行计划，这时候需要把这些逻辑执行计划转化成实际的物理执行计划，因为这些执行计划都是逻辑上面的，落到任务上面应该 如何 具体 去做，这时候需要把这些执行计划转成具体的执行计划，如何做，怎么做，拿join来说，逻辑执行计划里面可能就是 join操作，我们知道join的策略有很多种，我们应该使用哪种join策略，这时候就是在物理执行阶段需要做的。</p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/spark/">spark</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2024/01/08/spark%E8%83%8C%E5%8E%8B/">
                        <span class="hidden-mobile">spark背压</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments" lazyload>
                
                  
                
                
  <script type="text/javascript">
    Fluid.utils.loadComments('#comments', function() {
      var light = 'github-dark';
      var dark = 'github-dark';
      var schema = document.documentElement.getAttribute('data-user-color-scheme');
      if (schema === 'dark') {
        schema = dark;
      } else {
        schema = light;
      }
      window.UtterancesThemeLight = light;
      window.UtterancesThemeDark = dark;
      var s = document.createElement('script');
      s.setAttribute('src', 'https://utteranc.es/client.js');
      s.setAttribute('repo', 'leeseven-li/leeseven-li.github.io');
      s.setAttribute('issue-term', 'pathname');
      
      s.setAttribute('label', 'utterances');
      
      s.setAttribute('theme', schema);
      s.setAttribute('crossorigin', 'anonymous');
      document.getElementById('comments').appendChild(s);
    })
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <i class="iconfont icon-love"></i> <i class="iconfont icon-love"></i> <i class="iconfont icon-love"></i> <i class="iconfont icon-love"></i> <i class="iconfont icon-love"></i> <i class="iconfont icon-love"></i> <i class="iconfont icon-love"></i> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- 不蒜子统计PV -->
        <span id="busuanzi_container_site_pv" style="display: none">
            总访问量 
            <span id="busuanzi_value_site_pv"></span>
             次
          </span>
      
      
        <!-- 不蒜子统计UV -->
        <span id="busuanzi_container_site_uv" style="display: none">
            总访客数 
            <span id="busuanzi_value_site_uv"></span>
             人
          </span>
      
    
  </div>


  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
        typing(title);
      
    })(window, document);
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
